<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>One step at a time ... </title>
    <link>https://remyn.github.io/tutorials/</link>
    <language>en-us</language>
    <author>remyn</author>
    <rights>(C) 2016</rights>
    <updated>2016-08-18 14:30:58 &#43;1200 NZST</updated>

    
      
        <item>
          <title>Load balance containers</title>
          <link>https://remyn.github.io/tutorials/post/load-balance/</link>
          <pubDate>Thu, 18 Aug 2016 14:30:58 NZST</pubDate>
          <author>remyn</author>
          <guid>https://remyn.github.io/tutorials/post/load-balance/</guid>
          <description>

&lt;p&gt;A simple way to load balance containers inside a cluster.&lt;/p&gt;

&lt;p&gt;First start or setup a virtual machine that will act as our cluster. If necessary, refer to &lt;a href=&#34;https://remyn.github.io/tutorials/tutorials/post/docker-start/&#34;&gt;Docker start&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the following, we will use the virtual machine created before named &lt;code&gt;docker-host&lt;/code&gt;. And we assume, you have set up the environment variable to connect to the docker daemon of the virtual machine.&lt;/p&gt;

&lt;h2 id=&#34;create-the-cluster&#34;&gt;Create the cluster&lt;/h2&gt;

&lt;p&gt;We are going to create another environment variable containing the IP address of our virtual machine.&lt;/p&gt;

&lt;p&gt;It will be useful for our cluster creation. For that purpose, we use docker-machine to tell us what is the IP address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export DOCKER_IP=$(docker-machine ip docker-host)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we just need to create the cluster with &lt;code&gt;docker-compose&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you didn&amp;rsquo;t get the &lt;a href=&#34;https://github.com/remyn/tutorials-files&#34;&gt;repository&lt;/a&gt;, you can download directly the composition file &lt;a href=&#34;https://github.com/remyn/tutorials-files/raw/master/compose-cluster.yml&#34;&gt;compose-cluster.yml&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-compose -f compose-cluster.yml up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The composition file instruct docker to setup the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1 x Zookeeper&lt;/li&gt;
&lt;li&gt;1 x Mesos server&lt;/li&gt;
&lt;li&gt;1 x Mesos agent&lt;/li&gt;
&lt;li&gt;1 x Marathon&lt;/li&gt;
&lt;li&gt;1 x Traefik&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first time, it will be a little longer because it needs to pull the container images from the public repository of docker.&lt;/p&gt;

&lt;p&gt;list the containers&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also check the logs of the containers to be sure, everything has been set up properly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker logs docker_demo_zk_1
docker logs docker_demo_master_1
docker logs docker_demo_slave_1
docker logs docker_marathon_1
docker logs docker_demo_traefik_1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mesos-marathon-traefik&#34;&gt;Mesos, Marathon, Traefik&lt;/h2&gt;

&lt;p&gt;Mesos manage your computing resources - typically cpu, ram. Every agent reports the resources available.
You can have more details at the &lt;a href=&#34;http://mesos.apache.org/&#34;&gt;mesos website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Marathon will schedule the containers against the resources.
You can have more details at the &lt;a href=&#34;https://mesosphere.github.io/marathon/&#34;&gt;marathon website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Traefik is a dynamic reverse proxy. It will redirect the HTTP traffic to the appropriate container. It will act as a load balancer.
You can find more information on the &lt;a href=&#34;http://traefik.io/&#34;&gt;website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now there are all up and running you can check there web interfaces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;C:\Program Files (x86)\Mozilla Firefox\firefox.exe&amp;quot; http://$(echo $DOCKER_IP):5050 for Mesos
&amp;quot;C:\Program Files (x86)\Mozilla Firefox\firefox.exe&amp;quot; http://$(echo $DOCKER_IP):8080 for Marathon
&amp;quot;C:\Program Files (x86)\Mozilla Firefox\firefox.exe&amp;quot; http://$(echo $DOCKER_IP):8088 for Traefik
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;That&amp;rsquo;s it !&lt;/em&gt; We have a cluster running locally simulated by containers. But it will be the same principle, if you have several instances of mesos agent as full EC2 instances for examples. In our current local cluster an full EC2 instance is simulated by a agent container.&lt;/p&gt;

&lt;h2 id=&#34;load-balancing&#34;&gt;Load balancing&lt;/h2&gt;

&lt;p&gt;Inside the composition file, we also started a simple rest application, named &lt;code&gt;whoami&lt;/code&gt; that just reply to a GET pushing back its local IP. It is handy to check load balancing.
We have 2 instances (I mean - container)  of the same application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -H Host:whoami.docker.localhost http://$(echo $DOCKER_IP)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you execute the previous command several time, you will see that each request is handle by the 2 deployed containers alternatively.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Notice, that we don&amp;rsquo;t communicate directly with the container here. We simply send the request to the HOST IP address.
Traefik will automatically redirect the request to the container that can handle the request. It balances automatically between the number of containers running.
Traefik updates in real time the configuration. No need to stop the service, update the configuration file and restart it when you scale the containers up or down.
Just start more or stop containers and Traefik will automatically notice the difference.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;creating-our-own-asp-net-core-container&#34;&gt;Creating our own asp.net core container&lt;/h2&gt;

&lt;p&gt;It is easy to use some already created container. What about creating our own one.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Let&amp;rsquo;s do it!&lt;/em&gt;
For the purpose of this exercise, we are going to create a simple ASP.NET core (WEBAPI) that will take a json payload on a POST - just to have more fun - and reply back with the IP address of the host. Once again it is handy to test load balancing.&lt;/p&gt;

&lt;h3 id=&#34;return-the-ip-address-of-the-container&#34;&gt;Return the IP Address of the container&lt;/h3&gt;

&lt;p&gt;You can get the solution of the &lt;a href=&#34;https://remyn.github.com/tutorials-files/payrun&#34;&gt;project&lt;/a&gt;. Or alternatively, just create your own ASP.NET Core and in one of of your controller insert the IP address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var request = UriHelper.GetEncodedUrl(HttpContext.Request);
HttpContext.Response.Headers.Add(&amp;quot;From HOST&amp;quot;, GetIP());

private string GetIP()
{
    return String.Join(&amp;quot;,&amp;quot;, NetworkInterface.GetAllNetworkInterfaces()
                 .SelectMany(i =&amp;gt; i.GetIPProperties().UnicastAddresses)
                 .Select(i =&amp;gt; i.Address)
                 .Where(i =&amp;gt; i.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork &amp;amp;&amp;amp; !IPAddress.IsLoopback(i))
                 .Select(i =&amp;gt; i.ToString()));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now we have an application that is able to handle some HTTP Request and reply back adding the IP Address of the host into the header.
We can debug it, run it on our windows computer.&lt;/p&gt;

&lt;h3 id=&#34;create-the-container&#34;&gt;Create the container&lt;/h3&gt;

&lt;p&gt;Here, we have an ASP.NET Core application. I mean it is a cross platform application that can be self hosted (using kestrel). It can be executed on Windows or Linux.
We can create an container that we can deploy either on Windows or on Linux. It is a deployment choice not a compilation one.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;So let&amp;rsquo;s create the container.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;First, if it is not already the case, put a dockerfile - named dockerfile without extension - into the project folder, that looks like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM microsoft/dotnet:latest
COPY . /app
WORKDIR /app
RUN [&amp;quot;dotnet&amp;quot;, &amp;quot;restore&amp;quot;]
RUN [&amp;quot;dotnet&amp;quot;, &amp;quot;build&amp;quot;]
EXPOSE 5000/tcp
ENTRYPOINT [&amp;quot;dotnet&amp;quot;, &amp;quot;run&amp;quot;, &amp;quot;--server.urls&amp;quot;, &amp;quot;http://*:5000&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In summary, it is an instruction file for Docker to build the container image. The file could be read as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start with the official Microsoft .Net Core image.&lt;/li&gt;
&lt;li&gt;Copy the all the project into the folder app of the container.&lt;/li&gt;
&lt;li&gt;Move to this folder.&lt;/li&gt;
&lt;li&gt;Execute dotnet restore =&amp;gt; Will load all the depnedencies of the project.&lt;/li&gt;
&lt;li&gt;Execute dotnet build =&amp;gt; I think it is clear enough!&lt;/li&gt;
&lt;li&gt;The container will expose the port 5000 other TCP. Our application is listening on this port.&lt;/li&gt;
&lt;li&gt;When the container start, execute dotnet run &amp;ndash;server.urls http://*:5000. In other words, run our application listening from any IP address on the port 5000.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To build the container, simply:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd to-your-project-folder
docker build -t payrun
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;What is happening here?&lt;/strong&gt;
First we are using the windows docker client that you have installed with Chocolatey in the &lt;a href=&#34;https://remyn.github.io/tutorials/tutorials/post/docker-start/&#34;&gt;previous article&lt;/a&gt;.
Then, as we have already setup the environment variables to connect with the docker daemon of our host, docker following the instructions of &lt;code&gt;dockerfile&lt;/code&gt;, transfer the project files to the linux box and create a container named &lt;code&gt;payrun&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can check the container images with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you should have a container image - an imuutable artifact - that can be deploy anywhere on any host Windows or Linux.&lt;/p&gt;

&lt;h3 id=&#34;deploy-the-container&#34;&gt;Deploy the container&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s use our container. To manually start our container, simply:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -t -d --name payrun_1 -p 5000:5000 payrun
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the previous command line, we ask docker to start the container named payrun, give the instance name payrun_1, match the port 5000 of the host to the port 5000 of the container.
And by the way, give back the control (with the -d) parameter.&lt;/p&gt;

&lt;p&gt;Contol it is running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check its logs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker logs payrun_1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;test-our-application&#34;&gt;Test our application&lt;/h3&gt;

&lt;p&gt;Our application should be reachable on the port 5000 inside the container.
Let&amp;rsquo;s try a direct call to the application. We deployed the container by matching the port 5000 of the host to the same number inside the container. So a request to the host IP using the port 5000, should end up inside the container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST -i -H &amp;quot;Content-Type: application/json&amp;quot; -d &amp;quot;{ &#39;Name&#39;:&#39;Payrun name&#39;, &#39;Schedule&#39;: &#39;Schedule name&#39; }&amp;quot; http://$(echo $DOCKER_IP):5000/payruns 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Voila!&lt;/em&gt;  You should see the answer with the header containing the IP address of the container.&lt;/p&gt;

&lt;h3 id=&#34;checking-the-dynamicc-proxy&#34;&gt;Checking the dynamicc proxy&lt;/h3&gt;

&lt;p&gt;According to what we said before, Traefik should have seen the new container, registered it automatically and be ready to transfer requests to it.&lt;/p&gt;

&lt;p&gt;First check its registration, got to the Traefik web interface - port 8088 of your host. You should see under the docker tab, the service &lt;code&gt;payrun_1&lt;/code&gt; registered with a frontend rule named &lt;code&gt;Host:payrun_1.docker.localhost&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: as we didn&amp;rsquo;t specifically assigned a label to the container Traefik automatically give it one based on convention.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s try it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST -i -H &amp;quot;Content-Type: application/json&amp;quot; -H &amp;quot;Host:payrun_1.docker.localhost&amp;quot; -d &amp;quot;{ &#39;Name&#39;:&#39;Payrun name&#39;, &#39;Schedule&#39;: &#39;Schedule name&#39; }&amp;quot; http://$(echo $DOCKER_IP):80/payruns
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;2 things to notice here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We are using the port 80, not the port 5000.&lt;/li&gt;
&lt;li&gt;We are incorporating into the header the frontend rule.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Because we have Traefik listening on the port 80 of the cluster IP Address. We just need to send the request to the &lt;code&gt;cluster&lt;/code&gt;, mentioning into the header the &lt;code&gt;service&lt;/code&gt; that need to handle the request.
Traefik will automatically redirect the request to the appropriate &lt;code&gt;container&lt;/code&gt;. We don&amp;rsquo;t need to know on which instance is the container,  what is the IP address of the container or even the port.&lt;/p&gt;

&lt;p&gt;Sometimes there is awesome &lt;strong&gt;magic&lt;/strong&gt; tool!&lt;/p&gt;

&lt;h2 id=&#34;scale-our-container&#34;&gt;Scale our container&lt;/h2&gt;

&lt;p&gt;What about scaling up or down? Marathon will manage that for us.
We can ask Marathon to ensure that 3 instances of our application is running at all times.
Create a deployment file &lt;code&gt;marathon-payrun.json&lt;/code&gt;, declariung the cpu, ram usage and the container parameters, taht looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;id&amp;quot;: &amp;quot;marathon-payrun&amp;quot;,
    &amp;quot;cpus&amp;quot;: 0.1,
    &amp;quot;mem&amp;quot;: 64.0,
    &amp;quot;instances&amp;quot;: 3,
    &amp;quot;container&amp;quot;: {
        &amp;quot;type&amp;quot;: &amp;quot;DOCKER&amp;quot;,
        &amp;quot;docker&amp;quot;: {
        &amp;quot;image&amp;quot;: &amp;quot;payrun&amp;quot;,
        &amp;quot;network&amp;quot;: &amp;quot;BRIDGE&amp;quot;,
        &amp;quot;portMappings&amp;quot;: [
            { &amp;quot;containerPort&amp;quot;: 5000, &amp;quot;hostPort&amp;quot;: 0, &amp;quot;protocol&amp;quot;: &amp;quot;tcp&amp;quot; }
        ]
        }
    },
    &amp;quot;healthChecks&amp;quot;: [
        {
        &amp;quot;protocol&amp;quot;: &amp;quot;HTTP&amp;quot;,
        &amp;quot;portIndex&amp;quot;: 0,
        &amp;quot;path&amp;quot;: &amp;quot;/api/values&amp;quot;,
        &amp;quot;gracePeriodSeconds&amp;quot;: 5,
        &amp;quot;intervalSeconds&amp;quot;: 20,
        &amp;quot;maxConsecutiveFailures&amp;quot;: 3
        }
    ],
    &amp;quot;labels&amp;quot;: {
        &amp;quot;traefik.weight&amp;quot;: &amp;quot;1&amp;quot;,
        &amp;quot;traefik.protocol&amp;quot;: &amp;quot;http&amp;quot;,
        &amp;quot;traefik.frontend.rule&amp;quot; : &amp;quot;Host:payrun.marathon&amp;quot;,
        &amp;quot;traefik.frontend.priority&amp;quot; : &amp;quot;10&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, create a deployment on marathon using this file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST http://$(echo $DOCKER_IP):8080/v2/apps -d @marathon-payrun.json -H &amp;quot;Content-type: application/json&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The previous command use the API interface, but the same action could be done thru the web interface.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Go on the Marathon web interface (port 8000) and check the deployment and the instances.&lt;/li&gt;
&lt;li&gt;Go on the Traefik web interface (port 8088), on the Marathon tab, check the new 3 instances are registered.&lt;/li&gt;
&lt;li&gt;Go on the Mesos web interface (port 5050) and check the resources used (3 x 0.1 cpu and 3 x 64 MB).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Did you notice, the frontend rule label specified inside the marathon file : &lt;code&gt;traefik.frontend.rule&amp;quot; : &amp;quot;Host:payrun.marathon&lt;/code&gt;.
So want to use this new &lt;code&gt;service&lt;/code&gt; deployed?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST -i -H &amp;quot;Content-Type: application/json&amp;quot; -H &amp;quot;Host:payrun.marathon&amp;quot; -d &amp;quot;{ &#39;Name&#39;:&#39;Payrun name&#39;, &#39;Schedule&#39;: &#39;Schedule name&#39; }&amp;quot; http://$(echo $DOCKER_IP):80/payruns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As previously, we are sending the request to the port 80 of the host.Traefik will do the job to know how to reach and load balance the service. Repeat the previous command several times and check the IP Address of the container to see that each instance is used alternatively.&lt;/p&gt;

&lt;p&gt;Want more instance? Just scale the deployment from the Marathon interface or from its API. As long as Mesos reports enough resources, you will have what you want.&lt;/p&gt;

&lt;p&gt;Finally, you check what your services are really consuming by checking the containers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker stats 
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Starting with docker</title>
          <link>https://remyn.github.io/tutorials/post/docker-start/</link>
          <pubDate>Tue, 16 Aug 2016 11:32:49 NZST</pubDate>
          <author>remyn</author>
          <guid>https://remyn.github.io/tutorials/post/docker-start/</guid>
          <description>

&lt;p&gt;docker-machine : a simple tool to manage our virtual machines hosting our containers.&lt;/p&gt;

&lt;h1 id=&#34;docker&#34;&gt;Docker&lt;/h1&gt;

&lt;p&gt;For the unlucky user that doesn&amp;rsquo;t have Windows 10, we can&amp;rsquo;t have a native docker daemon. Instead, we are going to use docker from a linux box.
Here we are going to create a virtual machine with a lightweigth linux set up with a docker daemon.&lt;/p&gt;

&lt;p&gt;All the following command should be enter inside a &lt;code&gt;git-bash&lt;/code&gt; command line tool. If you have installed Git support for your VS2015 it should be installed.
Just start one instance as administrator and then go to your home folder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $HOME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can get the file used in this tutorial by cloning the repository &lt;a href=&#34;https://github.com/remyn/tutorials-files&#34;&gt;&lt;code&gt;tutorials&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/remyn/tutorials-files
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;get-the-tools&#34;&gt;Get the tools&lt;/h2&gt;

&lt;p&gt;First thing, we will need to load the 2 docker tools : &lt;code&gt;docker-machine&lt;/code&gt; and &lt;code&gt;docker-compose&lt;/code&gt;.
You can used the scripts &lt;a href=&#34;https://github.com/remyn/tutorials-files/raw/master/get-docker-machine.sh&#34;&gt;get-docker-machine.sh&lt;/a&gt; and &lt;a href=&#34;https://github.com/remyn/tutorials-files/raw/master/get-docker-compose.sh&#34;&gt;get-docker-compose.sh&lt;/a&gt; to download them into a given folder (e.g. &lt;strong&gt;docker-demo&lt;/strong&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./tutorials/get-docker-machine.sh docker-demo
./tutorials/get-docker-compose.sh docker-demo
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: If no folder is passed the default &lt;code&gt;docker-bin&lt;/code&gt; is used.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Great, so by now you should have the tools into the folder docker-demo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/docker-exe-folder.png&#34; alt=&#34;docker-exe-in-folder&#34; title=&#34;docker exe in folder.&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;create-the-virtual-machine&#34;&gt;Create the virtual machine&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s create a virtual machine with docker on it !
Here we are going to use HyperV but the same could be acheived with the VirtualBox driver. Use the one that you have already installed on your computer.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: It is one or the other, because once activated HyperV from your Windows features, VirtualBox can&amp;rsquo;t function anymore!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;cd docker-demo
docker-machine create --driver hyperv docker-host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With HyperV, if you prefer using a specific network interface (e.g. WIFI), you can indicate a virtual-switch with the &amp;ndash;hyperv-virtual-switch parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine create --driver hyperv --hyperv-virtual-switch &amp;quot;External LAN&amp;quot; docker-host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;That&amp;rsquo;s it !&lt;/em&gt; The virtual machine has been setup with a lightweight linux footprint. The latest docker daemon has been set up and it is running.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;List&lt;/strong&gt; the virtual machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Stop&lt;/strong&gt; the virtual machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine stop docker-host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Start&lt;/strong&gt; the virtual machine&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine start docker-host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Remove&lt;/strong&gt; (delete) the virtual-machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine rm docker-host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see that a simple executable suffice to manage the virtual machine. You can use another graphic tool to manage your virtual machine and push container into: &lt;a href=&#34;https://kitematic.com/&#34;&gt;https://kitematic.com/&lt;/a&gt; .&lt;/p&gt;

&lt;h2 id=&#34;remote-control-the-virtual-machine&#34;&gt;Remote control the virtual machine&lt;/h2&gt;

&lt;p&gt;To remote login into the virtual machine, we need to set up the environment variable that docker will use to communicate with the daemon (IP, port &amp;hellip;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine env docker-host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The previous command do just a print of the export command to create the environment variables. So to really create them, just execute the command by copying the last line printed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eval $(&amp;quot;C:\Users\remyn\bin\docker-machine.exe&amp;quot; env docker-host)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Remote login&lt;/strong&gt; with the virtual machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh docker-host
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;windows-docker-client&#34;&gt;Windows docker client&lt;/h2&gt;

&lt;p&gt;While we can&amp;rsquo;t have a native docker daemon on windows (8.1 and before), we can have a client one to natively send command to a docker daemon into a linux machine.&lt;/p&gt;

&lt;p&gt;From an administartor console, simply install first &lt;a href=&#34;http://chocolatey.org&#34;&gt;Chocolatey&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Then to install the client docker, just type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;choco install docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, you can simply communicate with teh docker daemon of your previous virtual machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    

  </channel>
</rss>
