<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>One step at a time ... </title>
    <link>https://remyn.github.io/tutorials/tags/mesos/</link>
    <language>en-us</language>
    <author>remyn</author>
    <rights>(C) 2016</rights>
    <updated>2016-08-18 14:30:58 &#43;1200 NZST</updated>

    
      
        <item>
          <title>Load balance containers</title>
          <link>https://remyn.github.io/tutorials/post/load-balance/</link>
          <pubDate>Thu, 18 Aug 2016 14:30:58 NZST</pubDate>
          <author>remyn</author>
          <guid>https://remyn.github.io/tutorials/post/load-balance/</guid>
          <description>

&lt;p&gt;A simple way to load balance containers inside a cluster.&lt;/p&gt;

&lt;p&gt;First start or setup a virtual machine that will act as our cluster. If necessary, refer to &lt;a href=&#34;https://remyn.github.io/tutorials/tutorials/post/docker-start/&#34;&gt;Docker start&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the following, we will use the virtual machine created  before named &lt;code&gt;docker-host&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;create-the-cluster&#34;&gt;Create the cluster&lt;/h2&gt;

&lt;p&gt;We are going to create another environment variable containing the IP address of our virtual machine.&lt;/p&gt;

&lt;p&gt;It will be useful for our cluster creation. For that purpose, we use docker-machine to tell us what is the IP address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export DOCKER_IP=$(docker-machine ip docker-host)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we just need to create the cluster with &lt;code&gt;docker-compose&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you didn&amp;rsquo;t get the &lt;a href=&#34;https://github.com/remyn/tutorials-files&#34;&gt;repository&lt;/a&gt;, you can download directly the composition file &lt;a href=&#34;https://github.com/remyn/tutorials-files/raw/master/compose-cluster.yml&#34;&gt;compose-cluster.yml&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-compose -f compose-cluster.yml up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The composition file instruct docker to setup the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1 x Zookeeper&lt;/li&gt;
&lt;li&gt;1 x Mesos server&lt;/li&gt;
&lt;li&gt;1 x Mesos agent&lt;/li&gt;
&lt;li&gt;1 x Marathon&lt;/li&gt;
&lt;li&gt;1 x Traefik&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first time, it will be a little longer because it needs to pull the container images from the public repository of docker.&lt;/p&gt;

&lt;p&gt;list the containers&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also check the logs of the containers to be sure, everything has been set up properly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker logs docker_demo_zk_1
docker logs docker_demo_master_1
docker logs docker_demo_slave_1
docker logs docker_marathon_1
docker logs docker_demo_traefik_1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mesos-marathon-traefik&#34;&gt;Mesos, Marathon, Traefik&lt;/h2&gt;

&lt;p&gt;Mesos manage your computing resources - typically cpu, ram. Every agent reports the resources available.
You can have more details at the &lt;a href=&#34;http://mesos.apache.org/&#34;&gt;mesos website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Marathon will schedule the containers against the resources.
You can have more details at the &lt;a href=&#34;https://mesosphere.github.io/marathon/&#34;&gt;marathon website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Traefik is a dynamic reverse proxy. It will redirect the HTTP traffic to the appropriate container. It will act as a load balancer.
You can find more information on the &lt;a href=&#34;http://traefik.io/&#34;&gt;website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now there are all up and running you can check there web interfaces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;C:\Program Files (x86)\Mozilla Firefox\firefox.exe&amp;quot; http://$(echo $DOCKER_IP):5050 for Mesos
&amp;quot;C:\Program Files (x86)\Mozilla Firefox\firefox.exe&amp;quot; http://$(echo $DOCKER_IP):8080 for Marathon
&amp;quot;C:\Program Files (x86)\Mozilla Firefox\firefox.exe&amp;quot; http://$(echo $DOCKER_IP):8088 for Traefik
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;That&amp;rsquo;s it !&lt;/em&gt; We have a cluster running locally simulated by containers. But it will be the same principle, if you have several instances of mesos agent as full EC2 instances for examples. In our current local cluster an full EC2 instance is simulated by a agent container.&lt;/p&gt;

&lt;h2 id=&#34;load-balancing&#34;&gt;Load balancing&lt;/h2&gt;

&lt;p&gt;Inside the composition file, we also started a simple rest application, named &lt;code&gt;whoami&lt;/code&gt; that just reply to a GET pushing back its local IP. It is handy to check load balancing.
We have 2 instances (I mean - container)  of the same application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -H Host:whoami.docker.localhost http://$(echo $DOCKER_IP)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you execute the previous command several time, you will see that each request is handle by the 2 deployed containers alternatively.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Notice, that we don&amp;rsquo;t communicate directly with the container here. We simply send the request to the HOST IP address.
Traefik will automatically redirect the request to the container that can handle the request. It balances automatically between the number of containers running.
Traefik updates in real time the configuration. No need to stop the service, update the configuration file and restart it when you scale the containers up or down.
Just start more or stop containers and Traefik will automatically notice the difference.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;creating-our-own-asp-net-core-container&#34;&gt;Creating our own asp.net core container&lt;/h2&gt;

&lt;p&gt;It is easy to use some already created container. What about creating our own one.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Let&amp;rsquo;s do it!&lt;/em&gt;
For the purpose of this exercise, we are going to create a simple ASP.NET core (WEBAPI) that will take a json payload on a POST - just to have more fun - and reply back with the IP address of the host. Once again it is handy to test load balancing.&lt;/p&gt;

&lt;h3 id=&#34;return-the-ip-address-of-the-container&#34;&gt;Return the IP Address of the container&lt;/h3&gt;

&lt;p&gt;You can get the solution of the &lt;a href=&#34;https://remyn.github.com/tutorials-files/payrun&#34;&gt;project&lt;/a&gt;. Or alternatively, just create your own ASP.NET Core and in one of of your controller insert the IP address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var request = UriHelper.GetEncodedUrl(HttpContext.Request);
HttpContext.Response.Headers.Add(&amp;quot;From HOST&amp;quot;, GetIP());

private string GetIP()
{
    return String.Join(&amp;quot;,&amp;quot;, NetworkInterface.GetAllNetworkInterfaces()
                 .SelectMany(i =&amp;gt; i.GetIPProperties().UnicastAddresses)
                 .Select(i =&amp;gt; i.Address)
                 .Where(i =&amp;gt; i.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork &amp;amp;&amp;amp; !IPAddress.IsLoopback(i))
                 .Select(i =&amp;gt; i.ToString()));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now we have an application that is able to handle some HTTP Request and reply back adding the IP Address of the hsot into the header.
We can debug it, run it on our windows computer.&lt;/p&gt;

&lt;h3 id=&#34;create-the-container&#34;&gt;Create the container&lt;/h3&gt;

&lt;p&gt;Put the docker file into the project folder
Move to the project folder
docker build -t payrun .&lt;/p&gt;

&lt;h3 id=&#34;deploy-the-container&#34;&gt;Deploy the container&lt;/h3&gt;

&lt;p&gt;docker run -t -d &amp;ndash;name payrun_1 -p 5000:5000 payrun&lt;/p&gt;

&lt;h3 id=&#34;test-our-application&#34;&gt;Test our application&lt;/h3&gt;

&lt;p&gt;Direct call
curl -X POST -i -H &amp;ldquo;Content-Type: application/json&amp;rdquo; -d &amp;ldquo;{ &amp;lsquo;Name&amp;rsquo;:&amp;lsquo;Payrun name&amp;rsquo;, &amp;lsquo;Schedule&amp;rsquo;: &amp;lsquo;Schedule name&amp;rsquo; }&amp;rdquo; http://$(echo $DOCKER_IP):5000/payruns&lt;/p&gt;

&lt;p&gt;Check Traefik to see the new container registered
So using dynamic routing
curl -X POST -i -H &amp;ldquo;Content-Type: application/json&amp;rdquo; -H &amp;ldquo;Host:payrun_1.docker.localhost&amp;rdquo; -d &amp;ldquo;{ &amp;lsquo;Name&amp;rsquo;:&amp;lsquo;Payrun name&amp;rsquo;, &amp;lsquo;Schedule&amp;rsquo;: &amp;lsquo;Schedule name&amp;rsquo; }&amp;rdquo; http://$(echo $DOCKER_IP):80/payruns&lt;/p&gt;

&lt;h2 id=&#34;scale-our-container&#34;&gt;Scale our container&lt;/h2&gt;

&lt;p&gt;Deploy payrun marathon
Manually or by script
curl -X POST http://$(echo $DOCKER_IP):8080/v2/apps -d @marathon-payrun.json -H &amp;ldquo;Content-type: application/json&amp;rdquo;&lt;/p&gt;

&lt;p&gt;curl -X POST -i -H &amp;ldquo;Content-Type: application/json&amp;rdquo; -H &amp;ldquo;Host:payrun.marathon&amp;rdquo; -d &amp;ldquo;{ &amp;lsquo;Name&amp;rsquo;:&amp;lsquo;Payrun name&amp;rsquo;, &amp;lsquo;Schedule&amp;rsquo;: &amp;lsquo;Schedule name&amp;rsquo; }&amp;rdquo; http://$(echo $DOCKER_IP):80/payruns&lt;/p&gt;

&lt;p&gt;Scale the application manually (could be done by script)&lt;/p&gt;

&lt;p&gt;docker stats&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
